<?xml version="1.0" encoding="UTF-8"?>
<p:declare-step xmlns:p="http://www.w3.org/ns/xproc"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:c="http://www.w3.org/ns/xproc-step"
  xmlns:cx="http://xmlcalabash.com/ns/extensions" 
  xmlns:tr="http://transpect.io"
  xmlns:sc="http://transpect.io/schematron-config"
  xmlns:sch="http://purl.oclc.org/dsdl/schematron" 
  xmlns:svrl="http://purl.oclc.org/dsdl/svrl"
  version="1.0" 
  name="apply-fixes" type="tr:apply-xsl-fixes">

  <p:input port="reports" primary="true">
    <p:documentation>A reports wrapper document as generated by tr:batch-val-sts. The xml:base attributes 
    contain the base URIs of the validated files, plus an extension '.val'. The IDs of svrl:failed-assert
    or svrl:successful-report messages will be used to look up sc:fix-xsl attributes in the assembled Schematron
    file in order to identify URIs of fixing XSLT (resolved against their sch:pattern’s base URI).</p:documentation>
  </p:input>
  <p:input port="source" sequence="true">
    <p:documentation>The validated STS source documents. They will be selected by base URI (as calculated from the
      SVRL’s base URI, minus trailing '.val'). If there is no such document on this port, an attempt is made to load it
      from the location given by the report’s base URI.</p:documentation>
    <p:empty/>
  </p:input>
  <p:input port="schematron">
    <p:documentation>An assembled Schematron document, possibly with sc:fix-xsl attributes.</p:documentation>
  </p:input>

  <p:output port="result" primary="true" sequence="true">
    <p:documentation>The hopefully fixed documents from the source port. The base URI will be augmented by replacing
    an '.xml' suffix by '.fixed.xml'.</p:documentation>
  </p:output>

  <p:option name="debug-dir-uri" select="''"/>
  <p:option name="debug" select="'no'"/>

  <p:import href="http://transpect.io/xproc-util/file-uri/xpl/file-uri.xpl"/>
  <p:import href="http://xmlcalabash.com/extension/steps/library-1.0.xpl"/>
  <p:import href="http://transpect.io/xproc-util/load/xpl/load-sources.xpl"/>

  <p:declare-step type="tr:apply-fixes-recursion" name="apply-fixes-recursion-decl">
    <p:input port="fixes" primary="true">
      <p:documentation>An sch:schema document with sc:xsl-fix children. The first sc:xsl-fix will be applied,
      then this sc:xsl-fix element will be removed and the step will be invoked with the remaining sch:schema
      document, until all sc:xsl-fixes have been removed from the document.
      The purpose of this recursion is that each subsequent fix be applied to the output of the preceding fix.
      This is not possible with a plain p:for-each iteration over all sc:xsl-fixes.</p:documentation>
    </p:input>
    <p:input port="source">
      <p:documentation>The document to be fixed</p:documentation>
    </p:input>
    <p:output port="result" primary="true"/>
    
    <p:option name="debug-dir-uri" select="''"/>
    <p:option name="debug" select="'no'"/>
    
    <p:import href="http://transpect.io/xproc-util/store-debug/xpl/store-debug.xpl"/>
    
    <p:for-each name="fix-source">
      <p:iteration-source select="/sch:schema/sc:xsl-fix[1]"/>
      <p:output port="result" primary="true"/>
      <p:variable name="fix-xsl-href" select="/sc:xsl-fix/@href"/>
      <p:variable name="fix-xsl-mode" select="xs:QName(/sc:xsl-fix/@mode)" cx:type="xs:QName"/>
      <!--<cx:message name="b">
        <p:with-option name="message" select="'bbbbbbbbbbb ', string-join(for $a in /*/@* return concat(name($a), '=', $a), ' ')"></p:with-option>
      </cx:message>-->
      <p:load name="load-xsl">
        <p:with-option name="href" select="$fix-xsl-href"/>
      </p:load>
      <cx:message>
        <p:with-option name="message" select="'UUUUUUUUUUU ', base-uri()">
          <p:pipe port="source" step="apply-fixes-recursion-decl"/>
        </p:with-option>
      </cx:message>
      <p:sink name="sink4"/>
      <p:xslt name="fix-current-source-doc">
        <p:with-option name="output-base-uri" select="replace(base-uri(), '(\.fixed)?\.xml$', '.fixed.xml')">
          <p:pipe port="source" step="apply-fixes-recursion-decl"/>
        </p:with-option>
        <p:with-option name="initial-mode" select="$fix-xsl-mode"/>
        <p:input port="source">
          <p:pipe port="source" step="apply-fixes-recursion-decl"/>
        </p:input>
        <p:input port="parameters" select="/sc:xsl-fix/c:param-set">
          <p:pipe port="current" step="fix-source"/>
        </p:input>
        <p:input port="stylesheet">
          <p:pipe port="result" step="load-xsl"/>
        </p:input>
      </p:xslt>
      <cx:message>
        <p:with-option name="message" select="'VVVVVVVVVVV ', base-uri()"/>
      </cx:message>
      <tr:store-debug name="store-patched">
        <p:with-option name="active" select="$debug"/>
        <p:with-option name="base-uri" select="$debug-dir-uri"/>
        <p:with-option name="pipeline-step" 
          select="string-join(('apply-fix',
                               replace(base-uri(), '^.+/(.+?)\.xml$', '$1'), 
                               replace($fix-xsl-href, '^.+/(.+?)\.xsl$', '$1'),
                               replace($fix-xsl-mode, ':', '_')),
                              '__')"/>
      </tr:store-debug>
    </p:for-each>
    <p:count name="count-fixed-doc"/>
    <p:choose name="conditionally-recurse">
      <p:when test=". = 0">
        <p:output port="result" primary="true"/>
        <p:documentation>no more fixes, return souce</p:documentation>
        <p:identity>
          <p:input port="source">
            <p:pipe port="source" step="apply-fixes-recursion-decl"/>
          </p:input>
        </p:identity>
      </p:when>
      <p:otherwise>
        <p:output port="result" primary="true"/>
        <p:delete match="/sch:schema/sc:xsl-fix[1]">
          <p:input port="source">
            <p:pipe port="fixes" step="apply-fixes-recursion-decl"/>
          </p:input>
        </p:delete>
        <tr:apply-fixes-recursion name="encore">
          <p:input port="source">
            <p:pipe port="result" step="fix-source"/>
          </p:input>
          <p:with-option name="debug" select="$debug"/>
          <p:with-option name="debug-dir-uri" select="$debug-dir-uri"/>
        </tr:apply-fixes-recursion>
      </p:otherwise>
    </p:choose>
  </p:declare-step>

  <p:variable name="error-ids-with-fixes" select="string-join(//(sch:assert | sch:report)[sc:xsl-fix]/@id, ' ')">
    <p:pipe port="schematron" step="apply-fixes"/>
  </p:variable>
  <p:variable name="report-uris-with-fixes"
     select="string-join(
               distinct-values(//(svrl:failed-assert | svrl:successful-report)
                                   [@id = tokenize($error-ids-with-fixes, '\s+')]/base-uri()),
               ' ')"/>
  <p:variable name="source-uris-with-fixes"
     select="string-join(
               for $ru in tokenize($report-uris-with-fixes, '\s+') return replace($ru, '\.val$', ''),
               ' ')"/>
  <!--<cx:message>
    <p:with-option name="message" select="'§§§§§§§§§§§§§§§§§§§§ 1111111 ', $error-ids-with-fixes, ' :: ', $report-uris-with-fixes"></p:with-option>
  </cx:message>-->
  <tr:load-sources name="load-sources">
    <p:input port="source">
      <p:pipe port="source" step="apply-fixes"/>
    </p:input>
    <p:with-option name="uris" select="$source-uris-with-fixes"/>
  </tr:load-sources>
  <p:for-each name="source-iteration">
    <p:variable name="base-uri" select="base-uri(/*)"/>
    <p:variable name="this-documents-error-ids-with-fixes" 
      select="string-join(
                distinct-values(/reports/svrl:schematron-output[@xml:base = concat($base-uri, '.val')]
                        /(svrl:failed-assert | svrl:successful-report)/@id[. = tokenize($error-ids-with-fixes, '\s+')]),
                ' ')">
      <p:pipe port="reports" step="apply-fixes"/>
    </p:variable>
    <!--<cx:message>
      <p:with-option name="message" select="'3333333 ', $this-documents-error-ids-with-fixes"/> 
    </cx:message>-->
    <p:xslt name="select-fixes-for-current-doc">
      <p:with-param name="ids" select="$this-documents-error-ids-with-fixes"/>
      <p:input port="parameters"><p:empty/></p:input>
      <p:input port="source">
        <p:pipe port="schematron" step="apply-fixes"/>
      </p:input>
      <p:input port="stylesheet">
        <p:inline>
          <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
            <xsl:param name="ids" as="xs:string"/>
            <xsl:key name="by-id" match="*[@id]" use="@id"/>
            <xsl:template match="/*">
              <xsl:message select="'aaaaaaaa ', $ids, count(tokenize($ids, '\s+')), count(key('by-id', tokenize($ids, '\s+')))"></xsl:message>
              <xsl:copy>
                <xsl:attribute name="xml:base" select="base-uri()"/>
                <xsl:for-each-group select="key('by-id', tokenize($ids, '\s+'))/sc:xsl-fix" 
                  group-by="string-join((@href, @mode, sc:param/@*), '__')">
                  <xsl:apply-templates select="."/>
                </xsl:for-each-group>
              </xsl:copy>
            </xsl:template>
            <xsl:template match="sc:xsl-fix">
              <xsl:copy>
                <xsl:attribute name="href" select="resolve-uri(@href, base-uri(.))"/>
                <xsl:copy-of select="@* except @href"/>
                <c:param-set>
                  <xsl:apply-templates select="sc:param"/>
                </c:param-set>
              </xsl:copy>
            </xsl:template>
            <xsl:template match="sc:param">
              <c:param name="{@name}" value="{@value}"/>
            </xsl:template>
          </xsl:stylesheet>
        </p:inline>
      </p:input>
    </p:xslt>
    <cx:message>
      <p:with-option name="message" select="'444444444 ', count(/*/*), /*/*/name()"></p:with-option>
    </cx:message>
    <tr:store-debug name="store-fix-list">
        <p:with-option name="active" select="$debug"/>
        <p:with-option name="base-uri" select="$debug-dir-uri"/>
        <p:with-option name="pipeline-step" 
          select="'fixes-list'"/>
      </tr:store-debug>
    <tr:apply-fixes-recursion name="apply-fixes-recursion">
      <p:input port="source">
        <p:pipe port="current" step="source-iteration"/>
      </p:input>
      <p:with-option name="debug" select="$debug"/>
      <p:with-option name="debug-dir-uri" select="$debug-dir-uri"/>
    </tr:apply-fixes-recursion>
  </p:for-each>
</p:declare-step>

<?xml version="1.0" encoding="UTF-8"?>
<p:declare-step xmlns:p="http://www.w3.org/ns/xproc"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:c="http://www.w3.org/ns/xproc-step"
  xmlns:cx="http://xmlcalabash.com/ns/extensions" 
  xmlns:tr="http://transpect.io"
  xmlns:sc="http://transpect.io/schematron-config"
  xmlns:sch="http://purl.oclc.org/dsdl/schematron" 
  xmlns:svrl="http://purl.oclc.org/dsdl/svrl"
  version="1.0" 
  name="apply-fixes" type="tr:apply-xsl-fixes">

  <p:input port="reports" primary="true">
    <p:documentation>A reports wrapper document as generated by tr:batch-val-sts. The xml:base attributes 
    contain the base URIs of the validated files, plus an extension '.val'. The IDs of svrl:failed-assert
    or svrl:successful-report messages will be used to look up sc:fix-xsl attributes in the assembled Schematron
    file in order to identify URIs of fixing XSLT (resolved against their sch:pattern’s base URI).</p:documentation>
  </p:input>
  <p:input port="source" sequence="true">
    <p:documentation>The validated STS source documents. They will be selected by base URI (as calculated from the
      SVRL’s base URI, minus trailing '.val'). If there is no such document on this port, an attempt is made to load it
      from the location given by the report’s base URI.</p:documentation>
    <p:empty/>
  </p:input>
  <p:input port="schematron">
    <p:documentation>An assembled Schematron document, possibly with sc:fix-xsl attributes.</p:documentation>
  </p:input>

  <p:output port="result" primary="true" sequence="true">
    <p:documentation>The hopefully fixed documents from the source port. The base URI will be augmented by replacing
    an '.xml' suffix by '.fixed.xml'.</p:documentation>
  </p:output>

  <p:import href="http://transpect.io/xproc-util/file-uri/xpl/file-uri.xpl"/>
  <p:import href="http://xmlcalabash.com/extension/steps/library-1.0.xpl"/>
  <p:import href="http://transpect.io/xproc-util/load/xpl/load-sources.xpl"/>

  <p:variable name="error-ids-with-fixes" select="//(sch:assert | sch:report)[sc:xsl-fix]/@id" cx:type="xs:string*">
    <p:pipe port="schematron" step="apply-fixes"/>
  </p:variable>
  <p:variable name="report-uris-with-fixes" cx:type="xs:string*"
     select="distinct-values(//(svrl:failed-assert | svrl:successful-report)[@id = $error-ids-with-fixes]/base-uri())"/>
  <p:variable name="source-uris-with-fixes" cx:type="xs:string*"
     select="for $ru in $report-uris-with-fixes return replace($ru, '\.val$', '')"/>
  <cx:message>
    <p:with-option name="message" select="'1111111 ', $error-ids-with-fixes, ' :: ', $report-uris-with-fixes"></p:with-option>
  </cx:message>
  <tr:load-sources name="load-sources">
    <p:input port="source">
      <p:pipe port="source" step="apply-fixes"/>
    </p:input>
    <p:with-option name="uris" select="string-join($source-uris-with-fixes, ' ')"/>
  </tr:load-sources>
  <p:for-each name="source-iteration">
    <p:variable name="base-uri" select="base-uri(/*)"/>
    <p:variable name="this-documents-error-ids-with-fixes" cx:type="xs:string*" 
      select="/reports/svrl:schematron-output[@xml:base = concat($base-uri, '.val')]
                        /(svrl:failed-assert | svrl:successful-report)/@id[. = $error-ids-with-fixes]">
      <p:pipe port="reports" step="apply-fixes"/>
    </p:variable>
    <cx:message>
      <p:with-option name="message" select="'3333333 ', $this-documents-error-ids-with-fixes"/> 
    </cx:message>
    <p:xslt name="select-fixes-for-current-doc">
      <p:with-param name="ids" select="$this-documents-error-ids-with-fixes"/>
      <p:input port="parameters"><p:empty/></p:input>
      <p:input port="source">
        <p:pipe port="schematron" step="apply-fixes"/>
      </p:input>
      <p:input port="stylesheet">
        <p:inline>
          <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
            <xsl:param name="ids" as="xs:string+"/>
            <xsl:key name="by-id" match="*[@id]" use="@id"/>
            <xsl:template match="/*">
              <xsl:copy>
                <xsl:attribute name="xml:base" select="base-uri()"/>
                <xsl:apply-templates select="key('by-id', $ids)/sc:xsl-fix"/>
              </xsl:copy>
            </xsl:template>
            <xsl:template match="sc:xsl-fix">
              <xsl:copy>
                <xsl:attribute name="href" select="resolve-uri(@href, base-uri(.))"/>
                <xsl:copy-of select="@* except @href"/>
                <c:param-set>
                  <xsl:apply-templates select="sc:param"/>
                </c:param-set>
              </xsl:copy>
            </xsl:template>
            <xsl:template match="sc:param">
              <c:param name="{@name}" value="{@value}"/>
            </xsl:template>
          </xsl:stylesheet>
        </p:inline>
      </p:input>
    </p:xslt>
    <p:for-each name="fix-source">
      <p:iteration-source select="/sch:schema/sc:xsl-fix"/>
      <p:load name="load-xsl">
        <p:with-option name="href" select="/sc:xsl-fix/@href"/>
      </p:load>
      <p:sink name="sink3"/>
      <p:xslt name="fix-current-source-doc">
        <p:with-option name="output-base-uri" select="replace(base-uri(), '\.xml$', '.fixed.xml')">
          <p:pipe port="current" step="source-iteration"/>
        </p:with-option>
        <p:with-option name="initial-mode" select="xs:QName(/sc:xsl-fix/@mode)">
          <p:pipe port="current" step="fix-source"/>
        </p:with-option>
        <p:input port="source">
          <p:pipe port="current" step="source-iteration"/>
        </p:input>
        <p:input port="parameters" select="/sc:xsl-fix/c:param-set">
          <p:pipe port="result" step="select-fixes-for-current-doc"/>
        </p:input>
        <p:input port="stylesheet">
          <p:pipe port="result" step="load-xsl"/>
        </p:input>
      </p:xslt>
    </p:for-each>
  </p:for-each>

</p:declare-step>
